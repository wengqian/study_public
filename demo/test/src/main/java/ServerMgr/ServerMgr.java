package ServerMgr;import java.util.ArrayList;import java.util.Date;import java.util.List;import java.util.Random;/** * Created by wengqian on 2017/4/13. */public class ServerMgr {    // 当服务器不可用时,重试等待时间（默认值）    private static final long WAIT_TIME_DEFAULT = 10;    // 最长重试等待时间（默认值）    private static final long WAIT_TIME_MAX_DEFAULT = 5 * 60;    // 获取服务器时的随机次数（默认值）    private static final int  RANDOM_TRY_TIMES_DEFAULT = 3;    // 服务器列表    private List<ServerInfo> serverInfolist;    // 重试等待时间    private long waitTimeBeforeRetry;    // 最长重试等待时间    private long maxWaitTimeBeforeRetry;    // 获取时随机次数    private int randomCount;    // 服务器个数    private int serverCount;    // 随机数生成器    private Random random;    public ServerMgr(List<ServerInfo> serverInfos) {        serverInfolist = new ArrayList<ServerInfo>();        for (ServerInfo serverInfo : serverInfos) {            serverInfolist.add(new ServerInfo(serverInfo.getIp(), serverInfo.getPort()));        }        waitTimeBeforeRetry = WAIT_TIME_DEFAULT;        maxWaitTimeBeforeRetry = WAIT_TIME_MAX_DEFAULT;        randomCount = RANDOM_TRY_TIMES_DEFAULT;        serverCount= serverInfolist.size();        random = new Random();        // 随机尝试次数不超过服务器数量        // 特别的,若服务器只有1台,则随机尝试次数为1        checkRandomCount();    }    /**     * 随机获取一个服务器,获取的服务器:     *  1)要么是可用的(即serverInfo.isValid()返回为true);     *  2)要么是不可用的(即serverInfo.isValid()返回为false)但是已经到达重试时间;     *  3)要么是不可用的且尚未到达重试时间,此时返回null。     *     *  获取服务器时,调用方应当首先调用本函数获取,对返回值的三种情况,调用方应该做如下处理:     *  (1)返回可用服务器的,如果使用时发现该服务器实际不可用,     *     则应当调用invalidateServer()函数使之失效,然后再次调用getServerByForce()函数强制获取一个服务器;     *  (2)返回不可用服务器的,若重试后发现该服务器恢复可用了,则应当调用validateServer()函数使之生效;     *     若重试后依然不可用,再应当再次调用invalidateServer()函数使之失效;     *     然后调用getServerByForce()强制获取一条连接;     *  (3)返回null的,直接调用getServerByForce()函数强制获取一个服务器。     *     *  获取服务器时,调用方正确的做法为,首先调用本函数获取服务器,若获取不到或者获取的服务器无法访问,则再调用getServerByForce()获取。     *  之所以要求首先调用本函数,是为了重试标记为不可用的服务器,以便短暂不可用的服务器恢复正常后可以及时被我们发现。     *     * @return     */    public ServerInfo getServerByRandom() {        if (serverInfolist.isEmpty()) {            return null;        }        // 随机获取一个服务器        int index = random.nextInt(this.serverCount);        ServerInfo serverInfo = serverInfolist.get(index);        if (serverInfo.isValid()) {            return serverInfo;        }        long now = new Date().getTime() / 1000;        if (now > serverInfo.getLastTryTime() + serverInfo.getWaitTime()) {            // 服务器已到达重试时间,给它一次机会,重试下            return serverInfo;        }        // 很不幸,获取的服务器既不可用,也没有达到重试时间,返回null        return null;    }    /**     * 强制获取一个服务器。本函数保证:     * 在有可用服务器的情况下,肯定返回一个可用服务器;     *   若所有服务器都不可用,则返回最早到达重试时间的那个服务器;     *     若所有服务器都没有到达重试时间,则返回null。     *     * 调用方应当首先调用getServerByRandom()函数获取服务器,获取不到或者获取的服务器使用后发现确实不可用,再调用本函数获取服务器，     * 否则,当某台服务器暂时不可用又恢复后,将导致该服务器长期饥饿。     *     * 函数首先尝试随机获取一个可用服务器,若尝试若干次都获取不到,     * 则遍历服务器列表池,获取第一个可用服务器;     *   若所有服务器都不可用,则返回最早到达重试时间的那个服务器;     *     若所有服务器都没有到达重试时间,则返回null。     *     * 函数保证了随机性。     *     * @return     */    public ServerInfo getServerByForce() {        // 避免无休止的随机        int randomCnt = this.randomCount;        while (randomCnt-- > 0) {            ServerInfo svrInfo = getServerByRandom();            if (svrInfo != null && svrInfo.isValid()) {                return svrInfo;            }        }        // 运气真不好,连续随机几次,获取的都是不可用的连接        // 用来记录最早到达重试时间的连接        ServerInfo earliestServerInfo = null;        long now = new Date().getTime() / 1000;        // 遍历服务器列表        for (ServerInfo serverInfo : serverInfolist) {            if (serverInfo.isValid()) {                // 返回第一个可用的服务器                return serverInfo;            }            // 判断服务器是否已达到重试时间            long tryAt = serverInfo.getLastTryTime() + serverInfo.getWaitTime();            if (now >= tryAt) {                if (earliestServerInfo == null ||                        tryAt < earliestServerInfo.getLastTryTime() + earliestServerInfo.getWaitTime()) {                    earliestServerInfo = serverInfo;                }            }        }        // 当所有的服务器都不可用时，返回最早到达重试时间的那个服务器        return earliestServerInfo;    }    /**     * 标记服务器不可用     * @param serverInfo     */    public void invalidateServer(ServerInfo serverInfo) {        long waitTime = serverInfo.getWaitTime();        if (waitTime == 0) {            // 从可用变为不可用            waitTime = this.waitTimeBeforeRetry;        } else {            // 重试后依然不可用,延长等待时间            waitTime *= 2;        }        // 重试等待时间不超过最大值        if (waitTime > this.maxWaitTimeBeforeRetry) {            waitTime = this.maxWaitTimeBeforeRetry;        }        serverInfo.setWaitTime(waitTime);        serverInfo.setLastTryTime(new Date().getTime() / 1000);        serverInfo.setValid(false);    }    /**     * 标记服务器可用     * @param serverInfo     */    public void validateServer(ServerInfo serverInfo) {        serverInfo.setWaitTime(0);        serverInfo.setValid(true);    }    public void setWaitTimeBeforeRetry(long waitTimeBeforeRetry) {        this.waitTimeBeforeRetry = waitTimeBeforeRetry;    }    public void setMaxWaitTimeBeforeRetry(long maxWaitTimeBeforeRetry) {        this.maxWaitTimeBeforeRetry = maxWaitTimeBeforeRetry;    }    public void setRandomCount(int randomCount) {        this.randomCount = randomCount;        checkRandomCount();    }    private void checkRandomCount() {        // 随机尝试次数不超过服务器数量        // 特别的,若服务器只有1台,则随机尝试次数为1        if (randomCount > serverCount) {            randomCount = serverCount;        }    }}